// A grammar file that lalrpop uses to generate the parser
use std::str::FromStr;
use ast::{Atom, List, Sexpr};

grammar;

// A Sexpr can be either a single atom, or a list of other Sexprs
pub sexpr: Sexpr = {
  <e:atom> => Sexpr::atom(e),
  <e:list> => Sexpr::list(e),
};

// A List is a VecDeque of zero or more Sexprs
list: List = {
  "(" <e:sexpr*> ")" => {
    let mut l = List::new();
    for s in e {
      l.push(s);
    }
    l
  },
};

pub atom: Atom = {
  <e:r"-?[0-9]+"> => Atom::Int(i64::from_str(e).unwrap()),
  <e:r"-?[0-9]+\.[0-9]+"> => Atom::Float(f64::from_str(e).unwrap()),
  <e:r#""[^\\"]*""#> => Atom::String(e[1..e.len()-1].to_string()),

  // booleans
  "true" => Atom::Bool(true),
  "false" => Atom::Bool(false),

  // We need to do single character symbols as a special case because otherwise
  // the grammar could be ambiguous.
  <e:r"[!?*$/^%+-]"> => Atom::Symbol(e.to_string()),

  // Everything else is a Symbol
  <e:r"[a-zA-Z_][\w\d!?*$/^%_-]*"> => Atom::Symbol(e.to_string()),
};
